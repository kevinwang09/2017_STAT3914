---
title: "`ggplot2` Tutorial"
author: | 
  | Kevin Wang
  | School of Mathematics and Statistics
output: 
  learnr::tutorial:
    progressive: true
    fig_height: 7
    fig_width: 7
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(ggplot2)
library(dplyr)
library(learnr)
library(gapminder)
knitr::opts_chunk$set(echo = FALSE)
tutorial_options(exercise.eval = FALSE)
```


## `ggplot2` introduction

+ `ggplot2` is a powerful data visualisation package in `R`.
+ The "gg" stands for "grammar of graphics", which means, the codes that is producing the plots has some sophisticated and rigourous logic behind it. 

+ (From Professor Di Cook) One central idea behind `ggplot2::ggplot` is that you should think about each plot as a statistic: it is a transformation of your data. 


## Building up layers of `ggplot`


### Blank ggplot

+ `ggplot2::ggplot()` must interact with `data.frame`

+ Run the code below. You should see a blank grey plot.

```{r blankggplot, exercise = T}
ggplot(iris)
```


### Adding aesthetics to ggplot

+ The reason that we got a blank plot is because we didn't tell `ggplot` what we want to see on this plot.

+ We know that there is a column call "Sepal.Length" and "Sepal.Width" in the `iris` data.frame, so let's use these as `x` and `y` aesthetics.


```{r addingAes1, exercise = T}
p = ggplot(iris, aes(x = Sepal.Length,
                     y = Sepal.Width))
p
```



```{r addingAes2, echo = F}
p = ggplot(iris, aes(x = Sepal.Length,
                     y = Sepal.Width))
```

+ Running the code above, we can see that these two variables are loaded onto the plot as aesthetics of the plot. 

+ But we didn't tell ggplot what sort of plot we want!! `ggplot` isn't going to guess what plot you want! If you want a scatter plot or a tile plot, you need to tell it explictly. 


### Adding `geom_` to ggplot

Adding `geom_` to your plot tells `R` you want to add a visualisation component to your data, and what sort of plot do you want.

For example, `geom_point()` tells `R` you want to use the previously defined `x` and `y` aesthetics to position points on your graph. i.e. you are doing a scatter plot!

```{r addingGeomPoint, exercise = T, exercise.setup = "addingAes2"}
p2 = p + geom_point()
p2
```


## Advantages of `ggplot2`

###  Automatic legend and colours

All plots should have legends, titles and axes labels. 

In base R, user need to specify most of these manually.

In ggplot, a lot of these are done automatically. 


```{r legends, exercise = T}
ggplot(iris, 
       aes(x = Sepal.Length,
           y = Sepal.Width,
           colour = Species)) + 
  geom_point()
```


### Facet

There are only that much things we can put on a graph: points, size, colours, text, lines, etc. And human eyes isn't very good at perceiving too many elements on a plot. Hence, we might need to split our data in some ways to create multiple plots. 

In base R, we will just run the plotting code on split data. 

In ggplot, if the data can be split into some small categories, then we can do that reletively easily. 

```{r facet, exercise = T, exercise.cap = "Uncomment the last line"}
ggplot(iris, 
       aes(x = Sepal.Length,
           y = Sepal.Width,
           colour = Petal.Length)) + 
  geom_point() +
  # facet_wrap(~Species, nrow = 3)
```


### Colours!

```{r colour_brewer, exercise = T, exercise.setup = "facet"}
last_plot() + scale_color_distiller(palette = "Spectral")
```

## Advanced considerations

### Reproducibility

In base R, it is possible to plot two (compatitable) objects together, even if they don't belong in the same `data.frame`. 

In ggplot, **by design**, you cannot do this! Everything are forced to be in a `data.frame`. While it might turn some people away from using it, it is actually critical in terms of reproducibility. It ensures that what you are plotting are of the correct dimensions and will always be a singular obejct. This is opposite to plotting vector `a` and `transformed.a`, two objects that are 500 lines of codes apart and therefore you will rely on your collaborator remembering if all transformations has been done correctly without permutation of indices...


```{r reproduce1, exercise = T, exercise.cap = "an example of the importance of pairing observations", exercise.setup = "facet"}
last_plot() + 
  geom_smooth(method = "lm")
```


```{r reproduce2, exercise = T, exercise.cap = "every ggplot has a copy of the data", exercise.setup = "facet"}
str(last_plot())
```



### Consistent appearance

In base R, if you want a series of graphs to appear consistent, you will need copy the code around

In `ggplot`, there are themes which you can modify globally and locally. This is particularly useful when you need graphs for publications.


```{r local theme change, exercise = T, exercise.cap = "add 'theme_bw()' to the plot and run"}
ggplot(iris, 
       aes(x = Sepal.Length,
           y = Sepal.Width,
           colour = Species)) + 
  geom_point() +
  # theme_bw()
```



```{r global theme change, exercise = T, exercise.cap = "uncomment the first line and execute the line"}
# theme_set() = theme_bw()
ggplot(iris, 
       aes(x = Sepal.Length,
           y = Sepal.Width,
           colour = Species)) + 
  geom_point() 
```



### Saving plots

Saving plots (without running the entire code again) could be difficult. This is particularly useful when you need graphs for publications.

```{r ggsave, exercise = T}
ggsave(filename = "myGGplot.png",
       plot = last_plot(),
       width = 5,
       height = 5,
       dpi = 300)
```



### Layered graphics

The ordering of `geom` matters, so you can create more flexible plots by adding extra `geom` on top of each other. 

Try to swap the `geom` below in the code. 

```{r layeredBoxplot, exercise = T, exercise.cap = "Try to swap geoms around"}
ggplot(iris, 
       aes(x = 1,
           y = Sepal.Length)) + 
  geom_jitter(width = 0.03) +
  geom_violin(alpha = 0) +
  geom_boxplot(width = 0.2) 
```



### ggplot as a statistic

As statisticians, we are familiar with the notion of a statistic as a transformed random variable. For example, let $(X_1, \dots X_n)$ be real valued random variables, then we can compute the mean as the summation (a transformation) of these RVs and then scale the sum by $\frac{1}{n}$ (another transformation). And we interprete the mean as an essential property of these RVs.

We should think of ggplot as a statistic. It accepts data (`data.frame`), which we can think of it as a RV. We then specify a list of transformations (`aes` and `geom`) to arrive at a meaningful representation 


## `gapminder` data example

### First look at the `gapminder` data

```{r}
glimpse(gapminder)
```

This is not a great visualisation, because it doesn't inform us the trends of GDP for countries nor continents. The best we can say is there are countries that are performing extremely well than the rest of the world.

```{r gapPoint, exercise = T}
gapminder %>%
  ggplot(aes(x = year,
           y = gdpPercap)) +
  geom_point()
```


This is perhaps the worst graph ever. Because it doesn't inform us anything. The vertical lines are joined for each year, yielding no meaning.


```{r gapPointLine1, exercise = T}
gapminder %>%
  ggplot(aes(x = year,
           y = gdpPercap)) +
  geom_point() +
  geom_line()
```


### `geom_line` a special beast

Maybe you haven't thought about it before, but the **grouping** of points are important in a line plot or a path plot. e.g. It made very little sense when we tried to join points within a year.


What if we set a **group** variable for our line plot?


```{r gapPointLine2, exercise = T}
gapminder %>%
  ggplot(aes(x = year,
             y = gdpPercap,
             group = country)) +
  geom_point() +
  geom_line()
```

Even better, we can incorporate extra information (continent) into the plot.

```{r gapPointLine3, exercise = T}
gapminder %>%
  ggplot(aes(x = year,
             y = gdpPercap,
             group = country,
             colour = continent)) +
  geom_point() +
  geom_line()
```



### Thinking about the data

As we discussed before, we should think of every `ggplot` as a statistic, which means, it has to inform us about at least one aspect of the data.

Plotting for the sake of plotting without careful thinking is like watching cat videos: it is fun but meaningless. 


We note that there is one outlier nation in Asia that skewed the plot a bit. Also, the GDP is on a rather large scale, which is "squashing" the whole plot.

We could turn the entire plot into a logarithm scale, but then, humans can't read logarithm scale very well. Thankfully, `ggplot` designers already thought of this!

```{r gapPointLineLog, exercise = T}
gapminder %>%
  ggplot(aes(x = year,
             y = gdpPercap,
             group = country,
             colour = continent)) +
  geom_point() +
  geom_line() +
  scale_y_log10()
```


### Highlighting continent aspects

We see most of Europe are doing very well in history, but majority of African nations are always at the bottom of the plot.

If we want, we can highlight construct the median GDP of each continent while also showing the nations.

One may argue there are too many features on this plot, and that is perfectly valid. It is perfectly fine to use `ggplot` to inform yourself, the analyst, first; before modifying it to your client's liking.

```{r gapSummary1, exercise = T}
gapminder %>%
  ggplot(aes(x = year,
             y = gdpPercap,
             group = country,
             colour = continent)) +
  geom_point(alpha = 0.4) +
  scale_y_log10() +
  stat_summary(aes(group = continent,
                   colour = continent),
               fun.y = median,
               geom = "line",
               size = 3)
```


```{r gapSummary2, exercise = T}
gapminder %>%
  ggplot(aes(x = year,
             y = gdpPercap,
             group = country,
             colour = continent)) +
  scale_y_log10() +
  stat_summary(aes(group = continent,
                   colour = continent),
               fun.y = median,
               fun.ymin = function(x) median(x) - mad(x),
               fun.ymax = function(x) median(x) + mad(x),
               geom = "errorbar",
               position = "dodge",
               size = 1)
```



## Extra `geom_`

### `geom_smooth`
`geom_smooth` will add a smoother to the current plot. The smoother can be linear models (`"lm"`) or robust linear model (`"rlm"`) or loess (`"loess"`) or gam (`"gam"`), generalised linear model (`"glm"`).



```{r smoother, exercise = T, exercise.cap = "Switch the smoother method to 'loess'"}
gapminder %>%
  ggplot(aes(x = lifeExp,
             y = gdpPercap,
             colour = continent)) +
  geom_point(alpha = 0.4) +
  geom_smooth(size = 2, method = "lm") +
  scale_y_log10() +
  theme_bw() +
  scale_color_brewer(palette = "Set1") +
  theme(legend.position = "bottom")
```

### `geom_text`

One of the most difficult plot to produce in base `R` graphics is to label points. 

In `ggplot2`, this difficult task is much simpler. Both `geom_text` or `geom_label` works well. 

```{r geom_text, exercise = T}
gapminder %>%
  filter(year == 2002) %>% 
  ggplot(aes(x = lifeExp,
             y = gdpPercap,
             label = country, 
             colour = continent)) +
  geom_text() +
  scale_y_log10() +
  theme_bw() +
  theme(legend.position = "bottom")
```


## `ggplot2` extension packages

### `ggrepel`
We note in the previous plot, we still have the problem of over-plotted texts. This problem is common enough that other R developers noticed this and developed `ggplot2` compatible packages for it. 

```{r geom_text_repel, exercise = T, exercise.cap = "replace 'geom_text' with 'geom_text_repel' "}
library(ggrepel)

gapminder %>%
  filter(year == 1957, 
         continent == "Europe") %>% 
  ggplot(aes(x = lifeExp,
             y = gdpPercap,
             label = country, 
             colour = continent)) +
  geom_point() +
  geom_text() +
  # geom_text_repel() +
  scale_y_log10() +
  theme_bw() +
  theme(legend.position = "bottom")

```





## Session Info
```{r}
sessionInfo()
```
